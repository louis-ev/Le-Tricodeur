<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
body {
  font-family: Helvetica, arial, sans-serif;

  width: 80%;
  max-width: 768px;
  margin:auto;

  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  color: #333;
  background-color: rgb(255,255,255);
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: normal;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

  h4, h5, h6 {
  	font-weight: bold;
  }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 38px;
  color: black; }

h2 {
  font-size: 30px;
  border-bottom: 1px solid #cccccc;
  color: black;
  font-weight: bold;
  }

h3 {
  font-size: 28px; }

h4 {
  font-size: 24px; }

h5 {
  font-size: 18px; }

h6 {
  color: #777777;
  font-size: 16px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%;
  border: 1px solid #eee;
  }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  font-family: "Menlo";
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 14px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-family: "Menlo";
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<title>Workshop Tricodeur</title>

</head>
<body>
<h1>Workshop Tricodeur</h1>

<h6>du 10 au 12 octobre 2014, préparé et encadré par Louis Eveillard</h6>

<hr />

<p>Photos et explications des productions sur <a href="http://www.letricodeur.com/">letricodeur.com</a></p>

<h3>Thématique</h3>

<p><strong>Créer puis tricoter des visualisations de données personnelles expressives et esthétiques. Explorer l'interaction entre la maille et le numérique pour la réappropriation des informations dématérialisées.</strong></p>

<p>Les programmes et les objets qui nous enregistrent à chaque instant ont envahi notre quotidien : profils facebook débordant de données privées, historique des recherches Google capturées à notre insu, portables et bracelets connectés enregistrant notre activité physique, notre position géographique, nos métadonnées de communication téléphoniques, etc. Ces informations sont convoitées par un grand nombre d'acteurs économiques et institutionnels mais ne sont que trop rarement récupérées et explorées par les citoyens qu'elles concernent et qui en sont les auteurs. Pourtant, ce travail de découverte et de réflexion à la fois instructif et introspectif permet de mieux comprendre la valeur de ces données et la nécessité de garder le contrôle sur elles. Il est important de créer les outils qui permettront de les percevoir, de les manipuler et d'appréhender ce qu'elle peuvent révéler de nous.</p>

<p>L'enjeu de ce workshop est de <strong>mettre en place des visualisation de données issues de jeux de données personnelles</strong> fournis par les participants eux-mêmes (profil Facebook ou Twitter, historique Google, échange de SMS, podomètre, etc.). Les images, qui seront produites avec les contraintes du tricot, iront du registre du descriptif à l'abstrait tout en restant systématiquement propre à leur porteur. Ainsi, les <strong>visualisations deviendront tangibles et permanentes</strong>, comme pour enregistrer un instant et donner à voir de manière poétique un aspect habituellement masqué de notre identité.</p>

<hr />

<h3>Contenus fournis et produits au workshop.</h3>

<p>Les contenus slides de conférence, bibliothèque de maille, exemples de visualisation (<a href="https://github.com/louis-ev/Le-Tricodeur">à télécharger sur github</a>) et initiation à Processing (ci-dessous) ont été produits par Louis Eveillard pour le workshop Tricodeur et sont sous license Creative Commons BY-SA.</p>

<p>La Famille de caractère Tricofonttype (<a href="https://github.com/louis-ev/Le-Tricodeur">à télécharger sur github</a>) à été créée par Émilie Coquard et est également sous license Creative Commons.</p>

<p>Les productions des participants du workshop (dossier SKETCHES_VIZ) sont la propriété de leurs auteurs respectifs et sont aussi sous license CC BY-SA.</p>

<ol>
<li><h3>Slides de la conférence du workshop</h3>

<ul>
<li>les origines du tricot,</li>
<li>les techniques de programmation de tricot,</li>
<li>la programmation pour créer des images et des formes,</li>
<li>la visualisation de données pour représenter des données abstraites</li>
<li>les enjeux de la visualisation de données personnelles</li>
<li><p>objectifs du workshop</p>

<p>Aperçu de l'ensemble des slides</p>

<p><img src="img/tricodeur-presentation-apercu-01.jpg" alt="image" /></p></li>
</ul>
</li>
<li><h3>La bibliothèque de maille</h3>

<ul>
<li>extension à Processing simulant l'affichage sur mailles dans une deuxième fenêtre sous Processing</li>
<li>utilisation en mode "template de départ" avec la possibilité de fouiller dans les fichiers sources</li>
<li><p>explications en bas de ce document.</p>

<p>Aperçu du rendu de la bibliothèque</p>

<p><img src="img/apercu-maille.png" alt="image" /></p></li>
</ul>
</li>
<li><h3>La tricofont</h3>

<ul>
<li>famille de caractère créée pour la maille par Émilie Coquard</li>
<li>occupe le moins de place possible</li>
<li>contient 3 variations : Regular, Italic et Bold</li>
<li><p>distribuée en Creative Commons avec attribution</p>

<p><img src="img/tricofont.png" alt="image" /></p></li>
</ul>
</li>
<li><h3>Les exemples d'utilisation de données Twitter et Facebook</h3>

<ul>
<li><p>visualisation dans l'espace de l'activité journalière des tweets des dernières années d'un compte
répartition par jour (colonne), mois (ligne) et année (bloc de ligne)</p>

<p><img src="img/visu-tweets.png" alt="image" /></p></li>
</ul>
</li>
</ol>


<h2>Initiation au design génératif et à la visualisation de données</h2>

<h3>Présentation de Processing</h3>

<p>Processing est à la fois un language de programmation et un logiciel dans lequel écrire ce langage. Il est orienté vers la production d'images et d'interfaces.</p>

<p>Quelques informations supplémentaires :</p>

<ul>
<li>conçu en 2001 par deux étudiants de John Maeda au MIT</li>
<li>à <em>destination des artistes et designers</em> non-codeurs (même si les codeurs l'apprécient aussi beaucoup)</li>
<li>pour la <em>création d'images</em> fixes, animées ou interactives</li>
<li>basé sur le JAVA, et extensible par le biais de bibliothèques riches et nombreuses</li>
<li><em>open-source</em> et développé par la communauté</li>
</ul>


<p>En Processing, les programmes sont appelés <em>sketch</em> (croquis en anglais) et peuvent être exportés pour être des applications autonomes.</p>

<h3>L'interface de Processing</h3>

<p>Elle est composée de boutons, d'onglets, d'une fenêtre d'édition et d'une console.</p>

<p><img src="img/processing-ide.png" alt="image" /></p>

<p>En haut à gauche de la fenêtre les boutons indispensables à connaître :</p>

<ul>
<li><em>lecture</em> pour exécuter un programme</li>
<li><em>stop</em> pour arrêter l'exécution d'un programme</li>
</ul>


<p>Les autres boutons sont des raccourcis pour accéder aux fonctions :</p>

<ul>
<li><em>créer un nouveau sketch</em>,</li>
<li><em>enregistrer sous</em>,</li>
<li><em>exporter une application</em>.</li>
</ul>


<p>Les <em>onglets</em> permettent de <em>découper un programme</em> en morceaux pour le rendre plus lisible et pratique à naviguer, mais cela n'a aucun autre effet. Tous les onglets visible dans une fenêtre Processing font partie du même et unique programme.</p>

<p>Le menu déroulant en haut à droite permet de changer de mode d'écriture du code. Il en existe plusieurs à l'heure d'aujourd'hui (mode JavaScript pour exporter pour le web, Android pour les Smartphones et Tablettes, ou PDE X qui est un éditeur avec des fonctionnalités supplémentaires). Ils sont cependant tous plus ou moins instables. Pour un application pour ordinateur, il vaut mieux rester avec le mode par défaut JAVA.</p>

<p>Les fichiers sauvegardés par Processing le sont avec l'extension <strong>.pde</strong> dans un dossier du même nom.</p>

<p>Enfin, les explications de chaque fonction sont disponibles à tout moment avec un <strong>clique droit -> références</strong>.</p>

<h3>Écrire un programme sur Processing</h3>

<h4>Affichage par défaut</h4>

<p>Un programme peut s'écrire avec très peu de choses en Processing. À vrai dire, exécuter un programme vide d'instructions donnera déjà un résultat :</p>

<p><img src="img/programme-vide.png" alt="image" /></p>

<h4>Les fonctions void setup() et void draw()</h4>

<p>Le fond gris et la taille sont donnés par défaut. Pour les remplacer, nous allons commencer par écrire les instructions suivantes.</p>

<pre class="brush:pde; gutter: false; ">
void setup() {  
}

void draw() {
}
</pre>


<p>La fonction <strong>setup()</strong> sera exécutée une seule fois, lorsque le programme sera démarré. Elle vient toujours avant la fonction <strong>draw()</strong>, qui sera elle exécutée en boucle indéfiniment. Les crochets ouvrants <strong>{</strong> signalent le début d'une fonction et les crochets fermants <strong>}</strong> signalent la fin de cette fonction. À noter que les fonctions setup et draw ne sont pas toujours indispensables, notamment pour des tests de variable de quelques lignes.</p>

<p>Pour nous souvenir des ces informations, nous pouvons commenter le programme (il est d'ailleurs indispensable de commenter correctement son code pour qu'il continue à être compréhensible par soi-même ou par les autres).</p>

<h4>Commentaires</h4>

<p>Dans processing, commenter signifie que le programme ne lira pas ce qui est écrit à cet endroit quelque soit le contenu. Le commentaire est exclusivement réservé aux humains. Le logiciel les affichera d'ailleurs en gris clair pour vous indiquer visuellement qu'ils ne sont pas pris en compte par le programme.</p>

<p>On peut écrire les commentaires de deux façons différentes.</p>

<ul>
<li>la première manière de faire consiste à précéder une ligne de deux barres obliques. Seul la ligne en question sera commentée et donc ignorée par le programme</li>
</ul>


<pre class="brush:pde; gutter: false; ">
    // exécuté une seule fois, quand le programme démarre
    void setup() {
        
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
    }
</pre>


<ul>
<li>les commentaires peuvent aussi être écrit avec une balise ouvrante et une balise fermante, ce qui donne :</li>
</ul>


<pre class="brush:pde; gutter: false; ">
    /*
        Programme développé par Louis
        pendant le workshop Tricodeur
        
        Licence CC BY-SA, avec attribution.
    */
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
    }
</pre>


<h4>Syntaxe</h4>

<p>Dernières précisions avant de commencer à coder : Processing a une syntaxe relativement contraignante.</p>

<ul>
<li><p>Chaque ligne d'instruction doit être <strong>terminée par un point virgule</strong>, par exemple background(255);</p></li>
<li><p>On peut placer des espaces à peut près n'importe où. Ainsi, rect(0,0,0,0) est équivalent à rect( 0, 0, 0, 0 ); On aura d'ailleurs tendance à <strong>bien espacer son code</strong> pour faciliter la relecture</p></li>
<li><p>Les lignes peuvent être indentées n'importe comment mais la convention veux qu'on ajoute des espaces en fonction des crochets. Processing fournit un outil de formatage automatique bien pratique qui corrige les indentations du code, il est accessible par les menus ou en tapant CTRL (ou COMMAND)&nbsp;+&nbsp;T.
Il convertit donc automatiquement</p></li>
</ul>


<pre class="brush:pde; gutter: false; ">
    void ligne_1() { 
    a = b + c; 
    for( int i=0; i < 5; i = i+1 ) { 
    rect( 5, i, 5, 5);
    }
    }
</pre>


<p>en</p>

<pre class="brush:pde; gutter: false; ">
    void ligne_1() {
        a = b + c;
        for( int i=0; i < 5; i = i+1 ) {
            rect( 5, i, 5, 5);
        }
    }
</pre>


<p>Nous pouvons maintenant passer au dessin !</p>

<h3>Dessiner avec Processing</h3>

<h4>Taille du dessin</h4>

<p>Pour commencer, nous pouvons ajuster la taille de notre dessin avec la fonction size( largeur, hauteur );
Elle doit être placée dans le void setup(), généralement en premier, ce qui donne :</p>

<pre class="brush:pde; gutter: false; ">

    /*
        Programme développé par Louis
        pendant le workshop Tricodeur
        
        Licence Creative Commons BY-SA.
    */
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
        
        size( 100, 140);
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
    }
</pre>


<p>Une fois lancé, on obtient :</p>

<p><img src="img/size-fct.png" alt="image" /></p>

<p>La surface de dessin est la partie en gris foncé. Elle ne prend pas toute la fenêtre car la taille minimale d'une fenêtre est de 129 pixels (et nous n'en voulons que 100 en largeur).</p>

<h4>Donner une couleur au fond de l'image</h4>

<p>Pour dessiner le fond du sketch avec une couleur, il suffit d'écrire <strong>background( nom_de_la_couleur );</strong></p>

<p>Cette ligne peut venir n'importe où dans le setup() ou dans le draw(), en fonction des besoins : dans le setup() la couleur ne sera appliquée qu'au lancement du programme, alors que dans le draw() elle sera appliquée à chaque exécution de la boucle.</p>

<p>En pratique, cela sert en général à effacer l'image précédente (en dessinant par dessus un rectangle blanc ou noir), alors qu'en mettant background() dans le setup() l'image produite à l'instant précédent est conservée dans le temps.</p>

<h4>Utiliser les couleurs</h4>

<p>Pour décrire une couleur, on peut utiliser les niveau de gris, le mode RGB, RGB avec transparence ou le mode hexadécimal (il y en a d'autres mais ils ne nous serons pas encore utiles). La valeur que l'on passe à la fonction de dessin va préciser le mode dans lequel on souhaite voir apparaître l'image.</p>

<ul>
<li>Une seule variable entière ( A ) = niveau de gris, noir et blanc, de 0 à 255 (le 0 étant le noir, 255 le blanc).</li>
<li>Trois variables ( R, G, B ) = valeurs Rouge Vert Bleu, dans cet ordre, de 0 à 255 (noir à couleur).</li>
<li>Quatre variables ( R, G, B, A ) = valeurs Rouge Vert Bleu et Alpha, Alpha étant la transparence de 0 à 255 (le 0 étant transparent, le 255 opaque).</li>
<li>Une seule variable hexadécimale ( #XXXXXX ) = n'importe quelle couleur sans transparence.</li>
</ul>


<p>Avec background, on obtient :</p>

<pre style="background-color: rgb(141, 141, 141 ) !important">background( 141 );</pre>


<pre style="background-color: rgb(255, 12, 75  ) !important">background( 255, 12, 75);</pre>


<pre style="background-color: rgba(255, 12, 75, 0.55) !important">background( 255, 12, 75, 140 );</pre>


<pre style="background-color: #7DC1C8 !important">background( #7DC1C8 );</pre>


<p>Notre programme ressemble maintenant à ça :</p>

<pre class="brush:pde; gutter: false; ">
/*
    Programme développé par Louis
    pendant le workshop Tricodeur
    
    Licence Creative Commons BY-SA.
*/

// exécuté une seule fois, quand le programme démarre
void setup() {
    
    size( 100, 140);
    // dessiner le fond de l'écran en vert clair
    background( #7DC1C8 );

}

// exécuté en boucle jusqu'à ce qu'on arrête le programme
void draw() {

}
</pre>


<p>et son exécution donne :</p>

<p><img src="img/background-fct.png" alt="image" /></p>

<p>À noter qu'il existe un sélecteur de couleur dans le menu Outils (Tools).</p>

<p><img src="img/selecteur-couleurs.png" alt="image" /></p>

<h4>Tracer des formes et du texte</h4>

<p>Les formes que Processing peut tracer sont globalement <strong>simples</strong>, mais c'est leur <strong>combinaison</strong> et/ou leur <strong>multiplicité</strong> qui créé des images complexes et raffinées. On les place dans le void draw().</p>

<p>Les formes sont tracées selon le système de repère de Processing, c'est à dire que l'ensemble des coordonnées ont pour origine le coin supérieur gauche. Le repère horizontal se nomme l'abscisse ou axe des X. Le repère vertical est l'ordonnée ou axe des Y.</p>

<p><img src="img/reperes.png" alt="image" /></p>

<p>Les formes de base les plus utilisées sont les suivantes :</p>

<ul>
<li><p><code>-    point( x, y );</code> =  un point en x, y</p></li>
<li><p><code>line( x1, y1, x2, y2 );</code> =  une ligne entre les points <strong>x1</strong>, <strong>y1</strong> et <strong>x2</strong>, <strong>y2</strong>,</p></li>
<li><p><code>rect( x, y, l, h );</code> =  un rectangle dont le coin supérieur gauche part de <strong>x</strong>, <strong>y</strong>, de largeur <strong>l</strong> et de hauteur <strong>h</strong>,</p></li>
<li><p><code>ellipse( x, y, diametreH, diametreV)</code> = une ellipse dont le centre est en <strong>x</strong>, <strong>y</strong>, et dont les diamètres horizontaux et verticaux sont respectivement <strong>diametreH</strong> et <strong>diametreV</strong>.</p></li>
</ul>


<p>Avec quelques formes on obtient.</p>

<pre class="brush:pde; gutter: false; ">
    /*
        Programme développé par Louis
        pendant le workshop Tricodeur.
        
        Licence Creative Commons BY-SA.
    */
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
        
        size( 100, 140);
        // dessiner le fond de l'écran en vert clair
        background( #7DC1C8 );
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
        rect( 10, 10, 20, 20);
        ellipse( 80, 44, 50,60 );
        line( 140, 10, 10, 80 );
    
    }
</pre>


<p>Ce qui vous donne :</p>

<p><img src="img/shapes-fct.png" alt="image" /></p>

<h4>Contour et couleur de remplissage</h4>

<p>Par défaut les formes sont remplies de blanc et possèdent un contour noir d'épaisseur 1 pixel.
Pour changer ces réglages, il faut déclarer une ou plusieurs des fonctions suivantes juste avant la ligne de la forme que nous allons changer. Ce réglage affecte toutes les formes qui viennent par la suite.</p>

<ul>
<li><p><code>fill( R, G, B )</code> change la couleur de remplissage</p></li>
<li><p><code>noFill()</code> supprime le contour</p></li>
<li><p><code>stroke( R, G, B )</code> change la couleur du contour</p></li>
<li><p><code>noStroke()</code> désactive la couleur de remplissage</p></li>
<li><p><code>strokeWeight( a )</code> change l'épaisseur du contour</p></li>
</ul>


<p>En reprenant notre exemple :</p>

<pre class="brush:pde; gutter: false; ">
/*
  Programme développé par Louis
  pendant le workshop Tricodeur.
  
  Licence Creative Commons BY-SA.
*/

// exécuté une seule fois, quand le programme démarre
void setup() {
  
  size( 100, 140);
  // dessiner le fond de l'écran en vert clair
  background( #7DC1C8 );

  // couleur de remplissage par défaut
  fill( 9, 96, 111 );

}

// exécuté en boucle jusqu'à ce qu'on arrête le programme
void draw() {

  // supprimer le contour du rectangle
  noStroke();
  rect( 10, 10, 20, 20); 
  
  // remettre un contour blanc à l'ellipse et à la ligne
  stroke( 255 );
  ellipse( 80, 44, 50,60 );
  line( 140, 10, 10, 80 );

}
</pre>


<p><img src="img/fill-stroke.png" alt="image" /></p>

<h4>Tracer du texte</h4>

<p>Le texte s'ajoute avec la fonction <code>text</code> qui demande trois paramètres : la chaîne de caractère à afficher, puis la position du bloc de texte en X et en Y. Le texte s'écrit à partir de ce point, en haut à droite (il est cependant possible de la center ou de le ferrer à droite par rapport au point).</p>

<p>Par exemple :</p>

<pre class="brush:pde; gutter: false; ">
text( "Titre du dessin", 5, 130 );
</pre>


<p>On peut le précéder d'un stroke() pour ajouter un contour au texte, ou un fill() pour changer la couleur du texte. Dans notre programme, nous pouvons donc écrire :</p>

<pre class="brush:pde; gutter: false; ">
    /*
      Programme développé par Louis
      pendant le workshop Tricodeur.
      
      Licence Creative Commons BY-SA.
    */
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
      
      size( 100, 140);
      // dessiner le fond de l'écran en vert clair
      background( #7DC1C8 );
    
      // couleur de remplissage par défaut
      fill( 9, 96, 111 );
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
      // supprimer le contour du rectangle
      noStroke();
      rect( 10, 10, 20, 20); 
      
      // remettre un contour blanc à l'ellipse et à la ligne
      stroke( 255 );
      ellipse( 80, 44, 50,60 );
      line( 140, 10, 10, 80 );
      
      // dessiner du texte après les formes (donc au dessus)
      noStroke();
      text( "Titre du dessin", 5, 130 );
      
    }
</pre>


<p>Il est également possible de changer la <em>taille du texte</em> et la <em>famille de caractère</em> avec laquelle il est écrit, mais pour cela il nous faut déclarer une variable. Nous verrons donc comment faire au chapitre suivant.</p>

<h3>Les variables</h3>

<h4>Typage des variables</h4>

<p>Les valeurs précédentes peuvent toutes êtes exprimés à l'aide de variables. Une variable s'écrit <strong>sans espaces</strong> et sans <strong>caractères spéciaux</strong> (accents, entre autre). On peut par contre employer “_”, “a”&nbsp;>&nbsp;“z”, “A”&nbsp;>&nbsp;“Z” ou “0”&nbsp;>&nbsp;“9”.</p>

<p><strong>Le nom d'une variable n'est pas anodin</strong> : il permet de comprendre très rapidement ce qu'elle va contenir, et permet parfois de se passer de commentaire. La <strong>longueur d'un nom de variable n'est pas limitée</strong>, alors n'hésitez pas à décrire le plus clairement possible son contenu grâce à son nom.</p>

<p>En Processing <strong>les variables sont typées</strong>, c'est à dire que ce qu'elles vont contenir doit être annoncé lors de leur création. Si le contenu d'une variable peut changer, son type est néanmoins figé jusqu'à l'arrêt du programme.
Les types les plus courants sont les suivants :</p>

<ul>
<li><p><code>int</code> = un nombre entier (sans virgule), par exemple <code>int tailleDuCercle = 128;</code></p></li>
<li><p><code>float</code>= un nombre à virgule, par exemple <code>float temperatureExterieure = 12.5;</code></p></li>
<li><p><code>color</code> = une couleur, à trois chiffres, par exemple <code>color fondDuDessin = color( 121, 12, 14 );</code></p></li>
<li><p><code>PFont</code> = une famille de caractère pour la fonction text(), par exemple <code>PFont maTypo;</code></p></li>
<li><p><code>String</code> = une chaîne de caractères, par exemple <code>String auteurDesTweets = "Benjamin Franklin";</code></p></li>
</ul>


<p>La déclaration des variables peut se faire dans le setup() ou dans le draw(), mais généralement elle a lieu avant même le setup(). Cela permet à ces variables d'être globales, c'est à dire qu'on peut s'en servir partout dans le programme.</p>

<h4>Dessiner des formes avec des variables</h4>

<p>Plutôt que de dessiner des formes à des coordonnées absolues, il est possible d'utiliser des variables directement dans les fonctions précédents.</p>

<p>Par exemple, pour dessiner 3 rectangles de la même taille :</p>

<pre class="brush:pde; gutter: false; ">
    int largeurRectangle = 12;
    int hauteurRectangle = 12;
    
    rect( 12, 24, largeurRectangle, hauteurRectangle );
    rect( 72, 48, largeurRectangle, hauteurRectangle );
    rect( 73, 86, largeurRectangle, hauteurRectangle );
</pre>


<p>Ou pour dessiner 3 rectangles de tailles différentes mais au même endroit.</p>

<pre class="brush:pde; gutter: false; ">
    int posX = 12;
    int posY = 12;
    
    rect( posX, posY, 42, 12 );
    rect( posX, posY, 32, 29 );
    rect( posX, posY, 16, 79 );
</pre>


<p>Il suffit de changer les variables déclarés pour affecter l'ensemble des formes. En reprenant notre sketch, nous pouvons donc placer le rectangle, la ligne et l'ellipse en fonction de la position de posX et posY. À noter que les variables sont déclarées avant le setup.</p>

<pre class="brush:pde; gutter: false; ">
    /*
      Programme développé par Louis
      pendant le workshop Tricodeur.
      
      Licence Creative Commons BY-SA.
    */
    
    int posX = 80;
    int posY = 42;
    
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
      
      size( 100, 140);
      // dessiner le fond de l'écran en vert clair
      background( #7DC1C8 );
    
      // couleur de remplissage par défaut
      fill( 9, 96, 111 );
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
      // supprimer le contour du rectangle
      noStroke();
      rect( posX-60, posY-20, 20, 20); 
      
      // remettre un contour blanc à l'ellipse et à la ligne
      stroke( 255 );
      ellipse( posX, posY, 50,60 );
      line( posX+60, posY, 10, 80 );
      
      // dessiner du texte après les formes (donc au dessus)
      noStroke();
      text( "Titre du dessin", 5, 130 );
      
    }
</pre>


<h4>Utiliser une variable pour modifier le style du texte</h4>

<p>Pour changer la famille de caractère utilisée par un texte, il faut d'abord créer une variable qui va le contenir, avant le setup. Elle est vide, on déclare simplement comment on s'en servira.</p>

<pre class="brush:pde; gutter: false; ">
    PFont maTypo; 
</pre>


<p>Dans le setup, on précise ce qu'on va y mettre :</p>

<pre class="brush:pde; gutter: false; ">
    maTypo = createFont( "tricofonttype", 8 );
    textFont( maTypo );
</pre>


<p>En reprenant notre sketch :</p>

<pre class="brush:pde; gutter: false; ">
    /*
      Programme développé par Louis
      pendant le workshop Tricodeur.
      
      Licence Creative Commons BY-SA.
    */
    
    int posX = 80;
    int posY = 42;
    
    PFont maTypo;
    
    // exécuté une seule fois, quand le programme démarre
    void setup() {
      
      size( 100, 140);
      // dessiner le fond de l'écran en vert clair
      background( #7DC1C8 );
    
      // couleur de remplissage par défaut
      fill( 9, 96, 111 );
      
      // charger la typo tricofonttype en taille 8
      maTypo = createFont( "tricofonttype", 8 );
      textFont( maTypo );
    
    }
    
    // exécuté en boucle jusqu'à ce qu'on arrête le programme
    void draw() {
    
      // supprimer le contour du rectangle
      noStroke();
      rect( posX-60, posY-20, 20, 20); 
      
      // remettre un contour blanc à l'ellipse et à la ligne
      stroke( 255 );
      ellipse( posX, posY, 50,60 );
      line( posX+60, posY, 10, 80 );
      
      // dessiner du texte après les formes (donc au dessus)
      noStroke();
      text( "Titre du dessin", 5, 130 );
      
    }
</pre>


<p>Et le rendu</p>

<p><img src="img/textfont.png" alt="image" /></p>

<p>Comme pour fill et stroke, textFont peut être remplacé dans le draw par exemple grâce à une autre variable PFont maDeuxiemeTypo.</p>

<p>Comme pour les valeurs X et Y des formes, on peut également afficher une variable dans text() au lieu d'une valeur prédéterminée.</p>

<pre class="brush:pde; gutter: false; ">
    String element = "Potassium";
    text( element, 5, 130 );
</pre>


<p>On peut aussi aller plus loin et manipuler des chaînes.</p>

<p><strong>Laissez le sketch développé jusqu'à présent de côté et démarrez en un nouveau.</strong></p>

<h4>Chaînes de caractère</h4>

<h5>Concaténer des chaînes</h5>

<p>On déclare donc une chaîne de caractère comme suit :</p>

<pre class="brush:pde; gutter: false; ">
    String planete = "Saturne"; 
    String satellite = "Titan";
</pre>


<p>On peut ensuite les mettre l'une à la suite l'une de l'autre. Cette opération s'appelle <strong>concaténer</strong> des chaînes, et se fait avec l'opérateur <strong>+</strong>.</p>

<pre class="brush:pde; gutter: false; ">
    String astres = planete + " et " + satellite;
</pre>


<p>Pour s'assurer que l'opération a bien eu lieu, nous pouvons utiliser le panneau de sortie et lui envoyer la valeur <strong>astres</strong>.</p>

<h5>Panneau de sortie</h5>

<p>Le panneau de sortie est le rectangle noir en dessous de l'encart d'écriture du programme.</p>

<p><img src="img/panneau-sortie.png" alt="image" /></p>

<p>Pour afficher le contenu d'une variable (ou de n'importe quel texte) dans le panneau de sortie, il suffit d'écrire println( maVariable );</p>

<p>En reprenant l'exemple précédent :</p>

<pre class="brush:pde; gutter: false; ">
    String planete = "Saturne"; 
    String satellite = "Titan";
    String astres = planete + " et " + satellite;
    
    void setup() {
        
        println( astres );

    }
    
    void draw() {
    
    }
</pre>


<p></p>

<p>Donnera</p>

<p><img src="img/panneau-sortie-ex.png" alt="image" /></p>

<h5>Compter la longueur d'une chaîne</h5>

<p>En visualisation de données, on a très souvent besoin de connaître la longueur d'une chaîne, c'est à dire le nombre de caractères qu'elle contient (par exemple, pour mesurer la longueur d'un tweet).
La fonction qui s'en charge s'appelle <strong>length()</strong>. Elle vient juste après le nom de la chaîne que l'on veut mesurer, et est précédé d'un point.</p>

<pre class="brush:pde; gutter: false; ">
    String monPremierTweet = "Hello World";
    
    void setup() {
        
        println( monPremierTweet.length() );

    }
    
    void draw() {
    
    }
</pre>


<p></p>

<p>Le panneau de sortie affichera la valeur 11 (les espaces comptent comme des caractères).</p>

<p>Lorsque le programme présente de nombreux appels à <code>println</code> il est très important de clarifier ce qui est envoyé au panneau de sortie. En reprenant l'exemple précédent :</p>

<pre class="brush:pde; gutter: false; ">
    String monPremierTweet = "Hello World";
    
    void setup() {
        
        println( "monPremierTweet = " + monPremierTweet + "    monPremierTweet.length() = " + monPremierTweet.length() + " caractères." );

    }
    
    void draw() {
    
    }
</pre>


<p>Après exécution du sketch :</p>

<p><img src="img/panneau-sortie-formattage.png" alt="image" /></p>

<h4>Tableaux</h4>

<h5>Initialisation</h5>

<p>Un tableau (array en anglais) est un type de variable qui contient une liste d'informations.</p>

<p>Par exemple, un tableau de l'âge des participants (des entiers donc) peut se présenter comme ceci :</p>

<pre class="brush:pde; gutter: false; ">
    int[] ageDesParticipants = { 22, 28, 32, 26, 20, 44 };
</pre>


<p>Pour afficher le contenu d'un tableau nous pouvons l'afficher dans le panneau de sortie :</p>

<pre class="brush:pde; gutter: false; ">
    printArray ( ageDesParticipants );
</pre>


<p>Ce qui donne</p>

<p><img src="img/array-output.png" alt="image" /></p>

<p>Chaque élément possède <strong>une position</strong>, elle est mentionnée entre des crochets dans le panneau de sortie. Dans notre programme, on peut utiliser cette position pour récupérer la valeur qui est présente à cet endroit du tableau, par exemple :</p>

<pre class="brush:pde; gutter: false; ">
    int ageDuPremierParticipant = ageDesParticipants[0];
    int ageDuDeuxiemeParticipant = ageDesParticipants[1];
    etc.
</pre>


<p>On pourrait donc construire un premier programme de visualisation en récupérant cette valeur et en l'utilisant pour dessiner des rectangles de hauteur différente.</p>

<h3>EXERCICE</h3>

<h4>En partant du sketch suivant (à copier/coller dans Processing), réalisez une visualisation de données permettant de comparer l'âge des participants.</h4>

<h5>BONUS : légendez chaque forme avec l'âge qui lui correspond.</h5>

<pre class="brush:pde; gutter: false; ">
    /*
      Programme développé par Louis
      pendant le workshop Tricodeur
      
      Exercice de visualisation
      
      Licence Creative Commons BY-SA.
    */
    
    int[] ageDesParticipants = { 22, 28, 32, 26, 20, 44 };
    
    PFont maTypo;
    
    void setup() {
      
      size( 100, 140);
      // dessiner le fond de l'écran en vert clair
      background( #7DC1C8 );
    
      // couleur de remplissage par défaut
      fill( 255 );
      
      // charger la typo tricofonttype en taille 8
      maTypo = createFont( "tricofonttype", 8 );
      textFont( maTypo );
        
    }
    
    void draw() {
      
      // récupérer la valeur du premier élément du tableau
      int ageDuPremierParticipant = ageDesParticipants[0];
      
      // petit rappel des paramètres pour dessiner un rectangle :
      // rect( positionX, positionY, largeur, hauteur );
      rect( 20, 120, 10, 10 );
      
      
    }
</pre>


<p>Si vous avez du mal à commencer, continuez de scroller vers le bas pour voir un indice.
</br>
</br>  <br/>
    </br>
    </br>
    </br>
    </br>
    </br></p>

<p></br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br></p>

<p>La variable <code>ageDuPremierParticipant</code> renvoi un entier, nous pouvons donc nous en servir dans rect(), ce qui pourrait donner :</p>

<p> <pre class="brush:pde; gutter: false; ">
    rect( 20, 120, ageDuPremierParticipant, 10);
</pre></p>

<p>Ce n'est pas idéal (le rectangle est tourné vers le bas), mais vous pouvez arranger ça en changeant les coordonnées.</p>

<p>La solution est un peu plus loin ci-dessous.</p>

<p></br>
</br>  <br/>
    </br>
    </br>
    </br>
    </br>
    </br></p>

<p></br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br></p>

<h3>SOLUTION</h3>

<p>La solution la plus logique avec les fonctions que nous avons déjà vu consiste à créer une variable pour chaque valeur du tableau et à l'utiliser dans les rectangles.</p>

<p>Chaque rectangle est aussi déplacé de 10 pixels vers la droite (la variable 30 passe à 40, puis à 50, 60, 70) :</p>

<pre class="brush:pde; gutter: false; ">
  int age2 = ageDesParticipants[1];
  rect( 30, 120 - age2, 10, age2 );

  int age3 = ageDesParticipants[2];
  rect( 40, 120 - age3, 10, age3 );
</pre>


<p>Le programme en entier :</p>

<pre class="brush:pde; gutter: false; ">
/*
  Programme développé par Louis
 pendant le workshop Tricodeur
 
 Exercice de visualisation
 
 Licence Creative Commons BY-SA.
 */

int[] ageDesParticipants = { 
  22, 28, 32, 26, 20, 44
};

PFont maTypo;

void setup() {

  size( 100, 140);
  // dessiner le fond de l'écran en vert clair
  background( #7DC1C8 );

  // couleur de remplissage par défaut
  fill( 255 );

  // charger la typo tricofonttype en taille 8
  maTypo = createFont( "tricofonttype", 8 );
  textFont( maTypo );
}

void draw() {

  // récupérer la valeur du premier élément du tableau
  int ageDuPremierParticipant = ageDesParticipants[0];

  // petit rappel des paramètres pour dessiner un rectangle :
  // rect( positionX, positionY, largeur, hauteur );
  rect( 20, 120 - ageDuPremierParticipant, 10, ageDuPremierParticipant );
  text( ageDuPremierParticipant, 20, 130 );

  int age2 = ageDesParticipants[1];
  rect( 30, 120 - age2, 10, age2 );
  text( age2, 30, 130 );

  int age3 = ageDesParticipants[2];
  rect( 40, 120 - age3, 10, age3 );
  text( age3, 40, 130 );

  int age4 = ageDesParticipants[3];
  rect( 50, 120 - age4, 10, age4 );
  text( age4, 50, 130 );

  int age5 = ageDesParticipants[4];
  rect( 60, 120 - age5, 10, age5 );
  text( age5, 60, 130 );

  int age6 = ageDesParticipants[5];
  rect( 70, 120 - age6, 10, age6 );
  text( age6, 70, 130 );
}
</pre>


<p><img src="img/solution-viz.png" alt="image" /></p>

<p>Ça fonctionne plutôt pas mal mais c'est long à écrire et on répète beaucoup de choses (en programmation comme dans la vie on déteste répéter les choses, et il y a toujours une manière de ne les écrire qu'une seule fois). Par exemple, s'il y avait eu 120 participants nous aurions passé 24 fois plus de temps à écrire tout ça !</p>

<p>En fait, ce que nous venons de faire reviens à <strong>avancer dans le tableau index par index</strong> pour lancer des fonctions dépendantes de la valeur située à cet index là. Heureusement, il existe une fonction qui est capable de faire ça, et elle s'appelle la boucle <strong>for</strong>.</p>

<h5>Boucle for</h5>

<p>La boucle for est une fonction dont on retrouve le principe dans presque tous les langages de programmation.</p>

<p>Elle permet de répéter un certain nombre de fois un certain nombre de lignes.</p>

<p>Par exemple, pour dessiner 10 rectangles nous pouvons dire :</p>

<pre class="brush:pde; gutter: false; ">
for( int i = 0; i < 10; i = i + 1 ) {
    rect( 15, 15, 30, 30);
} 
</pre>


<p>Ce qui revient à dire, en langage parlé :</p>

<ol>
<li>créer une variable dont la valeur est zéro</li>
<li>tant que la variable est inférieure à 10</li>
<li>alors exécute ce qui est dans la boucle, puis augmente là de 1</li>
</ol>


<p>Nous pouvons visualiser très facilement ce qui se passe pendant que la boucle s'exécute en ajoutant un println.</p>

<pre class="brush:pde; gutter: false; ">
for( int i = 0; i < 10; i = i + 1 ) {
    rect( 15, 15, 30, 30);
    println( "la variable i = " + i );
} 
</pre>


<p>Ce qui donne bien</p>

<p><img src="img/println-for.png" alt="image" /></p>

<p>La variable que nous utilisons dans les instructions même de la boucle for s'appelle l'index, et on la nomme en général d'une seul lettre : i, j, k, ou l, en fonction des variables encore non-attribuées.</p>

<p>L'index permet de différencier chaque exécution de la boucle for : il est la seule chose qui change à chaque répétition de cette boucle. Pour tracer des rectangles à des endroits différents à chaque exécution de la boucle for précédente, il suffit donc d'utiliser l'index dans les coordonnées du rectangle. Par exemple :</p>

<pre class="brush:pde; gutter: false; ">
for( int i = 0; i < 10; i = i + 1 ) {
    rect( i, i, 30, 30);
    println( "la variable i = " + i );
} 
</pre>


<p>Le premier rectangle sera dessiné en ( 0, 0, 30, 30), le second en ( 1, 1, 30, 30), le troisième en ( 2, 2, 30, 30) et ainsi de suite.</p>

<p>Comme c'est très souvent le cas, la variable i ne varie pas suffisamment pour nous permettre d'obtenir des formes bien séparées. Pour arranger ça, il suffit de créer un autre entier dont la valeur sera égale à un multiple de i, par exemple <code>int posRectangle = i * 10</code>.</p>

<pre class="brush:pde; gutter: false; ">
for( int i = 0; i < 10; i = i + 1 ) {
    // variable temporaire dont la valeur sera égale à 0, puis 10, puis 20, etc.
    int posRectangle = i * 10;
    rect( posRectangle, posRectangle, 30, 30);
    println( "la variable i = " + i );
} 
</pre>


<p>La <strong>boucle for est également indispensable pour parcourir un tableau</strong> : dans l'exemple précédent, plutôt que de faire appel à <code>ageDesParticipants[0]</code> puis <code>ageDesParticipants[1]</code> puis <code>ageDesParticipants[2]</code>, nous pouvons faire appel une seule fois à <code>ageDesParticipants[i]</code> dans une boucle for.</p>

<p>Nous pouvons maintenant réécrire une bien meilleure solution au programme précédent :</p>

<pre class="brush:pde; gutter: false; ">
/*
  Programme développé par Louis
 pendant le workshop Tricodeur
 
 Exercice de visualisation
 
 Licence Creative Commons BY-SA.
 */

int[] ageDesParticipants = { 
  22, 28, 32, 26, 20, 44
};

PFont maTypo;

void setup() {

  size( 100, 140);
  // dessiner le fond de l'écran en vert clair
  background( #7DC1C8 );

  // couleur de remplissage par défaut
  fill( 255 );

  // charger la typo tricofonttype en taille 8
  maTypo = createFont( "tricofonttype", 8 );
  textFont( maTypo );
}

void draw() {

  for ( int i = 0; i < 6; i = i + 1 ) {
    
    // on récupère l'index et on le multiplie pour obtenir une variable
    // positionEnX qui va bien de 0 à 
    int positionEnX = i * 10 + 20;
    // on récupère l'age du participant situé à la position = index
    int ageDuParticipant = ageDesParticipants[i];
    
    rect( positionEnX, 120 - ageDuParticipant, 10, ageDuParticipant );
    text( ageDuParticipant, positionEnX, 130 );
    
  }
  
}
</pre>


<p>Cette solution est non seulement beaucoup plus courte, elle est aussi beaucoup plus malléable : si nous souhaitons changer les coordonnées de l'ensemble des rectangles, ou supprimer ou ajouter des participants il sera toujours possible de le faire.</p>

<p>Néanmoins, notre boucle for n'est pas encore idéale : si nous modifions le jeu de donnée et le remplaçons par un autre, notre boucle ne marchera pas forcément car elle se répète précisément 6 fois. Il faudrait plutôt lui dire de se répéter autant de fois que nécessaire pour que chaque élément du tableau soit récupéré une seule fois.</p>

<p>Il existe une fonction bien pratique pour ça : length. Attention ! Si vous vous souvenez bien, nous avons vu la propriété length() pour compter la longueur d'une chaîne de caractère. length sans parenthèse s'applique lui à un tableau et compte le nombre de termes qui sont présents dedans.</p>

<p>Pour notre exemple</p>

<pre class="brush:pde; gutter: false; ">
println( "Nombre de participants : " + ageDesParticipants.length );
</pre>


<p>Affichera (à répétition car la boucle draw s'execute sans s'arrêter)</p>

<p><img src="img/println-length" alt="image" /></p>

<p>Ainsi, dans la boucle for initiale</p>

<pre class="brush:pde; gutter: false; ">
    for ( int i = 0; i < 6; i = i + 1 ) {
</pre>


<p>nous pouvons maintenant écrire</p>

<pre class="brush:pde; gutter: false; ">
    for ( int i = 0; i < ageDesParticipants.length; i = i + 1 ) {
</pre>


<p>C'est un peu plus long mais beaucoup plus pratique à utiliser ! Essayez maintenant de <strong>modifier le tableau ageDesParticipants</strong> en ajoutant ou en enlevant des entiers, le programme continuera à s'exécuter sans problème à chaque fois.</p>

<h5>Conditions if</h5>

<p>Dans une boucle for on a parfois envie d'ajouter des conditions supplémentaires pour améliorer la représentation. Avec notre exemple en place, on pourrait faire que la couleur d'une barre verticale dépendra de l'âge du participant : s'il est supérieur ou égale à 30 alors elle sera remplie de rouge, mais sinon elle sera remplie de blanc.</p>

<p>La fonction qui permet ça s'appelle <strong>if</strong> et accepte un type de variable particulier que nous n'avons pas encore vu, le <code>Boolean</code>. Celui-ci peut avoir deux états, vrai ou faux, ce qui fait que if est en quelque sorte <strong>un interrupteur</strong>. Si le booléen qui est dans sa parenthèse est vrai alors ce qui est dans le crochet qui le suit sera exécuté, sinon il ne le sera pas.</p>

<p>En pratique, on peut tout simplement écrire dans notre boucle for :</p>

<pre class="brush:pde; gutter: false; ">
if ( ageDuParticipant >= 30 ) {
    fill( #ff2719 );
}
</pre>


<p>et... ça ne marche pas. Toutes les barres sont en rouge alors que seules dont la valeur associée est de 30 ou plus devaient l'être.</p>

<p><img src="img/if-fct.png" alt="image" /></p>

<p>L'explication est en fait assez simple : notre programme tourne en boucle, et une fois que la fonction       <code>fill( #ff2719 );</code> a été exécutée toutes les formes suivantes (y compris les rectangles qui ne devraient pas l'être) sont dessinés en rouge.</p>

<p>Pour résoudre ce soucis, il faut s'assurer que les autres formes sont bien dessinées en blanc si elles sont en dessous de 30. On pourrait donc écrire une seconde fonction :</p>

<pre class="brush:pde; gutter: false; ">
if ( ageDuParticipant >= 30 ) {
    fill( #ff2719 );
}
if ( ageDuParticipant < 30 ) {
    fill( #ffffff );
}
</pre>


<p>Mais on peut faire plus concis (oui, oui !) et plus souple :</p>

<pre class="brush:pde; gutter: false; ">
if ( ageDuParticipant >= 30 ) {
    fill( #ff2719 );
} else {
    fill( #ffffff );
}
</pre>


<p>La fonction else peut venir directement après les crochets d'un if et désigne le cas inverse : <strong>si les conditions</strong> ne sont pas remplies, alors voici les fonctions à exécuter. Dans notre cas, remplir les formes qui suivent de blanc. <strong>Le bug venait donc d'une ambiguité</strong>, le programme appliquant des paramètres qui ne devaient pas l'être à toutes les formes. Nous avons clarifié notre intention au programme et tout marche maintenant normalement.</p>

<p><img src="img/if-else.png" alt="image" /></p>

<p>Et le code :</p>

<pre class="brush:pde; gutter: false; ">
/*
  Programme développé par Louis
 pendant le workshop Tricodeur
 
 Exercice de visualisation
 
 Licence Creative Commons BY-SA.
 */

int[] ageDesParticipants = { 
  22, 28, 32, 26, 20, 44
};

PFont maTypo;

void setup() {

  size( 100, 140);
  // dessiner le fond de l'écran en vert clair
  background( #7DC1C8 );

  // couleur de remplissage par défaut
  fill( 255 );

  // charger la typo tricofonttype en taille 8
  maTypo = createFont( "tricofonttype", 8 );
  textFont( maTypo );
}

void draw() {

  for ( int i = 0; i < ageDesParticipants.length; i = i + 1 ) {
    
    // on récupère l'index et on le multiplie pour obtenir une variable
    // positionEnX qui va bien de 0 à 
    int positionEnX = i * 10 + 20;
    // on récupère l'age du participant situé à la position = index
    int ageDuParticipant = ageDesParticipants[i];
    
    if ( ageDuParticipant >= 30 ) {
      fill( #ff2719 );
    } else {
      fill( #ffffff );
    }
    
    rect( positionEnX, 120 - ageDuParticipant, 10, ageDuParticipant );
    text( ageDuParticipant, positionEnX, 130 );
    
  }
  
  stop();
  
}
</pre>


<p>Nous avons maintenant en main toutes les pièces pour nous aider à réaliser des programmes de design génératif et de visualisation de donnée. Nous allons pouvoir nous attaquer au tricot, puis à de vrais données.</p>

<h2>3. Utilisation de la bibliothèque de maille</h2>

<p>Ouvrez le fichier bibliotheque_de_maille_01a.pde et lancez le.</p>

<p>Vous devriez voir ça.</p>

<p><img src="img/bibliotheque-renducanvas.png" alt="image" /></p>

<p><img src="img/bibliotheque-rendumaille.png" alt="image" /></p>

<p>Les deux affichantes sont synchronisés (quoi qu'il peut y avoir un léger décalage en fonction de la complexité de votre sketch).</p>

<h3>Contraintes du tricot</h3>

<h4>Taille</h4>

<p>Chaque pixel du dessin correspond à une maille dans le tricot. Cela veut donc dire que nous devons nous limiter à un sketch de moins de 200 pixels de large, car la machine ne peut pas tricoter davantage. Cependant, pour ce workshop nous nous limiterons à une résolution de 100 pixels de large sur 200 à 300 pixels de haut.</p>

<h4>Couleurs</h4>

<p>Le tricot en 2 couleurs passe très bien mais au-delà de 2 couleurs prend beaucoup de temps et est très complex. Nous nous contenterons donc de deux couleurs :)</p>

<h4>Aliasing</h4>

<p>Puisque nous avons 2 couleurs, nous ne pouvons pas non plus utiliser l'aliasing pour lisser des formes. En Processing, cette fonction s'appelle smooth(). Ci-dessous, à gauche, motif lissé (smooth()) et non-lissé (nosmooth()). À gauche, on voit bien le nombre de niveaux de gris alors qu'à droite</p>

<p><img src="img/aliasing-smooth.png" alt="image" /> <img src="img/aliasing-nosmooth.png" alt="image" /></p>

<p><img src="img/aliasing-smooth-4x.png" alt="image" /> <img src="img/aliasing-nosmooth-4x.png" alt="image" /></p>

<p>Pour être sûr de n'avoir que 2 couleurs, nous devons donc ajouter la fonction noSmooth(); dans le void setup(). Cette fonction est incluse dans la bibliothèque de mailles.</p>

<h4>Trames</h4>

<p>Si vous utilisez plus de 2 couleurs (noir + blanc + gris, rouge + noir + blanc, noir + blanc + gris foncé + gris clair, etc.) et que img2track est enregistré pour utiliser 2 couleurs alors il procèdera à tramer votre motif. La couleur la plus sombre et la plus claire sont prises comme références tandis que les couleurs qui sont entre les deux sont tramées pour simuler les teintes intermédiaires.</p>

<p><img src="img/trames-fb.png" alt="image" /> <img src="img/trames-fb-trames.png" alt="image" /></p>

<h2>4. Visualisation de données</h2>

<h3>Historique Twitter</h3>

<ul>
<li><p>Connectez vous à Twitter.com, et demandez votre archive de tweet de puis les paramètres.</p></li>
<li><p>Vous devriez récupérer un fichier .CSV qui contient l'ensemble de vos tweets.</p></li>
<li><p>Copiez ce fichier dans le dossier inititiation_twitter_timeline_00_base / DATASET</p></li>
<li><p>Ouvrez le sketch : inititiation_twitter_timeline_00_base.pde</p></li>
<li><p>Éditez les lignes</p>

<p><pre class="brush:pde; gutter: false; ">
nettoyerCSVDeTwitter( "DATASET/tweets-julien.csv", "DATASET/tweets-julien-new.csv");
</pre>
en remplaçant par</p>

<p><pre class="brush:pde; gutter: false; ">
nettoyerCSVDeTwitter( "DATASET/nom_de_votre_fichier.csv", "DATASET/nom_de_votre_fichier_propre.csv");
</pre></p></li>
<li><p>Modifiez ensuite</p>

<p> <pre class="brush:pde; gutter: false; ">
tweets = loadTable("DATASET/tweets-julien-new.csv", "header");
</pre>
en remplaçant ainsi :
 <pre class="brush:pde; gutter: false; ">
tweets = loadTable("DATASET/nom_de_votre_fichier_propre.csv", "header");
</pre></p></li>
<li><p>Exécutez ce programme. Vous devriez voir affiché dans le panneau de sortie des informations provenant de votre fichier de donnée.</p></li>
</ul>


<p>L'ensemble de la visualisation se fera en partant de ce programme. Si vous êtes perdu, vous pouvez néanmoins ouvrir les versions suivantes  :</p>

<p><strong>inititiation_twitter_timeline_01_a_aleatoire</strong> = visualisation avec des pixels aléatoires, chaque pixel représentant un tweet et est positionné aléatoirement dans l'espace du tricot</p>

<p><strong>inititiation_twitter_timeline_01_b_annee</strong> = répartition par année des tweets</p>

<p><strong>inititiation_twitter_timeline_01_c_legende</strong> = ajout d'une légende</p>

<p><strong>inititiation_twitter_timeline_01_d_mois</strong> = répartition des tweets par mois</p>

<p><strong>inititiation_twitter_timeline_01_e_jour</strong> = répartition par jour, suppression complète de l'aléatoire. La visualisation affiche maintenant un aperçu de l'activité jour après jour de l'auteur du profil twitter.</p>

<h3>Messages Facebook</h3>

<p>Un fichier XML exporté avec l'application pour Facebook : https://givememydata.com/</p>

<p>Installer l'application, choisir "Messages (inbox)" et exporter en XML. Créez un fichier facebook-messages.xml dans DATASET et copiez-y le contenu de la fenêtre de givememydata.</p>

<p>Les fonctions qui peuvent être utilisées sont expliquées dans la boucle draw().</p>

<h4>Ces deux exemples peuvent vous servirent de base de départ, n'hésitez pas à les détourner et les enrichir pour produire vos motifs génératifs ! Bon tricot !</h4>

<script src="sh/shCore.js"></script>


<p><link rel=stylesheet href="sh/shCore.css"></p>

<script src="sh/shBrushProcessing.js"></script>


<p><link rel=stylesheet href="sh/shProcessing2Theme.css">
<link rel=stylesheet href="sh/customStyleTricodeurInitiation.css"></p>

<script>SyntaxHighlighter.all();</script>



</body>
</html>